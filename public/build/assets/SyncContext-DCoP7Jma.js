import{b as C,r as f,j as v}from"./currencyStore-Dk9RVyyc.js";import{c as O,d as D,g as k,e as F}from"./productsService-Cx6SDGJw.js";import{b as _,c as $,d as R}from"./chargesService-CCVnmmfA.js";import{a as w,b as A,s as y}from"./database-DEIbwPOq.js";async function x(){try{return await w.count()}catch(t){return console.error("‚ùå Error counting collections:",t),0}}async function Y(){try{const t=await w.toArray(),e={},c=[];return t.forEach(r=>{e[r.id]={...r,children:[]},r.parent_id||c.push(e[r.id])}),t.forEach(r=>{r.parent_id&&e[r.parent_id]&&e[r.parent_id].children.push(e[r.id])}),console.log(`üå≥ Built hierarchy with ${c.length} root collections`),c}catch(t){return console.error("‚ùå Error building collection hierarchy:",t),[]}}async function j(t){try{return await w.bulkPut(t),console.log(`‚úÖ Synced ${t.length} collections to Dexie`),!0}catch(e){return console.error("‚ùå Error syncing collections:",e),!1}}async function U(){try{return await w.clear(),console.log("‚úÖ All collections cleared from Dexie"),!0}catch(t){return console.error("‚ùå Error clearing collections:",t),!1}}async function I(){try{return await A.count()}catch(t){return console.error("‚ùå Error counting contacts:",t),0}}async function B(t){try{const e=await A.where("type").equals(t).toArray();return console.log(`üë§ Found ${e.length} contacts of type ${t}`),e}catch(e){return console.error("‚ùå Error getting contacts by type:",e),[]}}async function Z(){try{return await B("customer")}catch(t){return console.error("‚ùå Error getting customers:",t),[]}}async function L(t){try{return await A.bulkPut(t),console.log(`‚úÖ Synced ${t.length} contacts to Dexie`),!0}catch(e){return console.error("‚ùå Error syncing contacts:",e),!1}}async function M(){try{return await A.clear(),console.log("‚úÖ All contacts cleared from Dexie"),!0}catch(t){return console.error("‚ùå Error clearing contacts:",t),!1}}async function z(){try{console.log("üîÑ Starting product sync...");const t=await d("products"),e=t?.lastSyncedAt?new Date(t.lastSyncedAt).getTime():null,c=e?`/api/sync?table=products&last_sync=${e}`:"/api/sync?table=products";console.log(`üìä Syncing products${e?" (incremental from "+new Date(e).toLocaleString()+")":" (full sync)"}`);const s=(await C.get(c)).data;if(s.status!=="success")throw new Error(s.message||"Sync failed");const o=s.data||[];if(!Array.isArray(o))throw new Error("Invalid response format: expected array of products");if(await O(o)){const a=s.timestamp?new Date(s.timestamp).toISOString():new Date().toISOString();return await y.put({key:"products",lastSyncedAt:a,count:o.length}),console.log(`‚úÖ Product sync completed: ${o.length} products synced`),{success:!0,count:o.length,timestamp:a}}else throw new Error("Failed to store products in Dexie")}catch(t){return console.error("‚ùå Product sync failed:",t),{success:!1,error:t.message,timestamp:new Date().toISOString()}}}async function d(t="products"){try{return await y.get(t)||null}catch(e){return console.error("‚ùå Error getting sync info:",e),null}}async function q(){try{console.log("üîÑ Starting charges sync...");const t=await d("charges"),e=t?.lastSyncedAt?new Date(t.lastSyncedAt).getTime():null,c=e?`/api/sync?table=charges&last_sync=${e}`:"/api/sync?table=charges";console.log(`üìä Syncing charges${e?" (incremental)":" (full sync)"}`);const s=(await C.get(c)).data;if(s.status!=="success")throw new Error(s.message||"Charges sync failed");const o=s.data||[];if(!Array.isArray(o))throw new Error("Invalid response format: expected array of charges");if(await _(o)){const a=s.timestamp?new Date(s.timestamp).toISOString():new Date().toISOString();return await y.put({key:"charges",lastSyncedAt:a,count:o.length}),console.log(`‚úÖ Charges sync completed: ${o.length} charges synced`),{success:!0,count:o.length,timestamp:a}}else throw new Error("Failed to store charges in Dexie")}catch(t){return console.error("‚ùå Charges sync failed:",t),{success:!1,error:t.message,timestamp:new Date().toISOString()}}}async function H(){try{console.log("üîÑ Starting collections sync...");const t=await d("collections"),e=t?.lastSyncedAt?new Date(t.lastSyncedAt).getTime():null,c=e?`/api/sync?table=collections&last_sync=${e}`:"/api/sync?table=collections";console.log(`üìä Syncing collections${e?" (incremental)":" (full sync)"}`);const s=(await C.get(c)).data;if(s.status!=="success")throw new Error(s.message||"Collections sync failed");const o=s.data||[];if(!Array.isArray(o))throw new Error("Invalid response format: expected array of collections");if(await j(o)){const a=s.timestamp?new Date(s.timestamp).toISOString():new Date().toISOString();return await y.put({key:"collections",lastSyncedAt:a,count:o.length}),console.log(`‚úÖ Collections sync completed: ${o.length} collections synced`),{success:!0,count:o.length,timestamp:a}}else throw new Error("Failed to store collections in Dexie")}catch(t){return console.error("‚ùå Collections sync failed:",t),{success:!1,error:t.message,timestamp:new Date().toISOString()}}}async function G(){try{console.log("üîÑ Starting contacts sync...");const t=await d("contacts"),e=t?.lastSyncedAt?new Date(t.lastSyncedAt).getTime():null,c=e?`/api/sync?table=contacts&last_sync=${e}`:"/api/sync?table=contacts";console.log(`üìä Syncing contacts${e?" (incremental)":" (full sync)"}`);const s=(await C.get(c)).data;if(s.status!=="success")throw new Error(s.message||"Contacts sync failed");const o=s.data||[];if(!Array.isArray(o))throw new Error("Invalid response format: expected array of contacts");if(await L(o)){const a=s.timestamp?new Date(s.timestamp).toISOString():new Date().toISOString();return await y.put({key:"contacts",lastSyncedAt:a,count:o.length}),console.log(`‚úÖ Contacts sync completed: ${o.length} contacts synced`),{success:!0,count:o.length,timestamp:a}}else throw new Error("Failed to store contacts in Dexie")}catch(t){return console.error("‚ùå Contacts sync failed:",t),{success:!1,error:t.message,timestamp:new Date().toISOString()}}}async function J(){try{console.log("üîÑ Starting full sync...");const t=await Promise.allSettled([z(),q(),H(),G()]),e={products:t[0].status==="fulfilled"?t[0].value:{success:!1,error:"Failed"},charges:t[1].status==="fulfilled"?t[1].value:{success:!1,error:"Failed"},collections:t[2].status==="fulfilled"?t[2].value:{success:!1,error:"Failed"},contacts:t[3].status==="fulfilled"?t[3].value:{success:!1,error:"Failed"}},c=Object.values(e).every(r=>r.success);return console.log("‚úÖ Full sync completed:",e),{success:c,summary:e,timestamp:new Date().toISOString()}}catch(t){return console.error("‚ùå Full sync failed:",t),{success:!1,error:t.message,timestamp:new Date().toISOString()}}}const T=f.createContext(null),K=()=>{const t=f.useContext(T);if(!t)throw new Error("useSyncContext must be used within SyncProvider");return t},N=({children:t})=>{const[e,c]=f.useState({status:"idle",progress:0,message:"",lastSyncedAt:null,totalProducts:0,totalCharges:0,totalCollections:0,totalContacts:0,localProducts:0,localCharges:0,localCollections:0,localContacts:0,error:null}),r=f.useCallback((i,n)=>{c(l=>({...l,progress:i,message:n||l.message}))},[]),s=f.useCallback(async i=>{c({status:"syncing",progress:0,message:"Initializing sync...",lastSyncedAt:null,totalProducts:0,totalCharges:0,totalCollections:0,totalContacts:0,localProducts:0,localCharges:0,localCollections:0,localContacts:0,error:null});try{r(10,"Connecting to server..."),await new Promise(u=>setTimeout(u,300)),r(30,"Fetching data from server...");const n=await J();if(!n.success)throw new Error("Sync failed for one or more tables");const l=n.summary.products?.count||0,g=n.summary.charges?.count||0,m=n.summary.collections?.count||0,p=n.summary.contacts?.count||0;r(60,`Processing ${l} products, ${g} charges, ${m} collections, ${p} contacts...`),await new Promise(u=>setTimeout(u,300)),r(80,"Storing data locally..."),await new Promise(u=>setTimeout(u,300)),r(100,"Sync complete!");const[P,b,S,E]=await Promise.all([D(),$(),x(),I()]);if(c({status:"success",progress:100,message:`Successfully synced ${l} products, ${g} charges, ${m} collections, ${p} contacts`,lastSyncedAt:n.timestamp,totalProducts:l,totalCharges:g,totalCollections:m,totalContacts:p,localProducts:P,localCharges:b,localCollections:S,localContacts:E,error:null}),setTimeout(()=>{c(u=>({...u,status:"idle"}))},3e3),i){const u=await k();i(u)}return{success:!0,summary:n.summary,productCount:l,chargeCount:g,collectionCount:m,contactCount:p,totalCount:l+g+m+p}}catch(n){return console.error("Sync error:",n),c({status:"error",progress:0,message:n.message||"Sync failed",lastSyncedAt:null,totalProducts:0,totalCharges:0,totalCollections:0,totalContacts:0,localProducts:0,localCharges:0,localCollections:0,localContacts:0,error:n.message}),setTimeout(()=>{c(l=>({...l,status:"idle"}))},5e3),{success:!1,error:n.message}}},[r]),o=f.useCallback(async()=>{try{const[i,n,l,g,m,p,P,b]=await Promise.all([d("products"),d("charges"),d("collections"),d("contacts"),D(),$(),x(),I()]),S=[i?.lastSyncedAt,n?.lastSyncedAt,l?.lastSyncedAt,g?.lastSyncedAt].filter(Boolean),E=S.length>0?S.sort().reverse()[0]:null;c(u=>({...u,lastSyncedAt:E,totalProducts:i?.count||0,totalCharges:n?.count||0,totalCollections:l?.count||0,totalContacts:g?.count||0,localProducts:m,localCharges:p,localCollections:P,localContacts:b}))}catch(i){console.error("Error loading sync info:",i)}},[]),h=f.useCallback(async i=>{try{return console.log("üîÑ Resetting sync data..."),await Promise.all([F(),R(),U(),M()]),await Promise.all([y.delete("products"),y.delete("charges"),y.delete("collections"),y.delete("contacts")]),c({status:"idle",progress:0,message:"",lastSyncedAt:null,totalProducts:0,totalCharges:0,totalCollections:0,totalContacts:0,localProducts:0,localCharges:0,localCollections:0,localContacts:0,error:null}),console.log("‚úÖ Sync data reset complete"),await s(i)}catch(n){return console.error("‚ùå Error resetting sync:",n),{success:!1,error:n.message}}},[s]),a={syncState:e,startSync:s,loadLastSyncInfo:o,resetSync:h};return v.jsx(T.Provider,{value:a,children:t})},tt=Object.freeze(Object.defineProperty({__proto__:null,SyncProvider:N,useSyncContext:K},Symbol.toStringTag,{value:"Module"}));export{N as S,Z as a,tt as b,Y as g,K as u};
